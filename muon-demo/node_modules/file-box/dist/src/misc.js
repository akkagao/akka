"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const http = require("http");
const https = require("https");
const nodeUrl = require("url");
function dataUrlToBase64(dataUrl) {
    const dataList = dataUrl.split(',');
    return dataList[dataList.length - 1];
}
exports.dataUrlToBase64 = dataUrlToBase64;
/**
 * Get http headers for specific `url`
 * follow 302 redirection for max `REDIRECT_TTL` times.
 *
 * @credit https://stackoverflow.com/a/43632171/1123955
 */
function httpHeadHeader(url) {
    return __awaiter(this, void 0, void 0, function* () {
        let REDIRECT_TTL = 7;
        while (true) {
            if (REDIRECT_TTL-- <= 0) {
                throw new Error('ttl expired! too many 302 redirections.');
            }
            const res = yield _headHeader(url);
            if (!/^3/.test(String(res.statusCode))) {
                return res.headers;
            }
            // console.log('302 found for ' + url)
            if (!res.headers.location) {
                throw new Error('302 found but no location!');
            }
            url = res.headers.location;
        }
        function _headHeader(destUrl) {
            return __awaiter(this, void 0, void 0, function* () {
                const parsedUrl = nodeUrl.parse(destUrl);
                const options = Object.assign({}, parsedUrl, { method: 'HEAD' });
                let request;
                if (parsedUrl.protocol === 'https:') {
                    request = https.request;
                }
                else if (parsedUrl.protocol === 'http:') {
                    request = http.request;
                }
                else {
                    throw new Error('unknown protocol: ' + parsedUrl.protocol);
                }
                return new Promise((resolve, reject) => {
                    request(options, resolve)
                        .on('error', reject)
                        .end();
                });
            });
        }
    });
}
exports.httpHeadHeader = httpHeadHeader;
function httpHeaderToFileName(headers) {
    const contentDisposition = headers['content-disposition'];
    if (!contentDisposition) {
        return null;
    }
    // 'content-disposition': 'attachment; filename=db-0.0.19.zip'
    const matches = contentDisposition.match(/attachment; filename="?(.+[^"])"?$/i);
    if (matches && matches[1]) {
        return matches[1];
    }
    return null;
}
exports.httpHeaderToFileName = httpHeaderToFileName;
function httpStream(url, headers = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        const parsedUrl = nodeUrl.parse(url);
        const protocol = parsedUrl.protocol;
        let options;
        let get;
        if (protocol === 'https:') {
            get = https.get;
            options = parsedUrl;
            options.agent = https.globalAgent;
        }
        else if (protocol === 'http:') {
            get = http.get;
            options = parsedUrl;
            options.agent = http.globalAgent;
        }
        else {
            throw new Error('protocol unknown: ' + protocol);
        }
        options.headers = Object.assign(options.headers || {}, Object.assign({}, headers));
        const res = yield new Promise(resolve => get(options, resolve));
        return res;
    });
}
exports.httpStream = httpStream;
function streamToBuffer(stream) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            const bufferList = [];
            stream.once('error', reject);
            stream.once('end', () => {
                const fullBuffer = Buffer.concat(bufferList);
                resolve(fullBuffer);
            });
            stream.on('data', buffer => bufferList.push(buffer));
        });
    });
}
exports.streamToBuffer = streamToBuffer;
//# sourceMappingURL=misc.js.map